Case uses === operator for comparision. When expression servers as lhs of the operator and case expression as serves as rhs.
How case equality operator works. 
mod === obj 
Case Equality returns true 
a)if obj is an instance of mod or
b)if the value of obj and mod are equal.
eg)
String==="a" #returns true as "a" is instance of string
"a"===String #this will return false because String is not the instance of "a" 
"a"==="a"    # returns true because values of both string object are same
String===String # returns false as no condition satisfies 




Ruby’s is dynamic in nature facilitates a style of type system known as duck typing. Duck typing breaks the strong association between an object’s class and its type by defining types based on what an object can do rather than what class it was born from. This changes everything about how we need to think about designing object oriented systems
Ruby is designed to support this style of objected oriented design. In this issue, we will cover some of the options that are available to us for doing Ruby-style type checking.
In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type. For example, in a non-duck-typed language, one would create a function that requires that the object passed into it be of type Duck, in order to ensure that that function can then use the object's walk and quack methods. In a duck-typed language, the function would take an object of any type and simply call its walk and quack methods, producing a run-time error if they are not defined.
eg)
def read_data(source)  
  return source.read if source.respond_to?(:read)  
  return File.read(source.to_str) if source.respond_to?(:to_str)  
  raise ArgumentError  
end   
putsread_data("read.txt")   #returns file content of read.txt
file=File.new("read.txt")
puts read_data(file)        #returns file content of read.txt    


In above example source is send to read_data method. Source is not expected to be of any particular type i.e it is duck typed. Source can be any object that has either read method or a to_str method. If both is not true then it will raise an exception. If source has a method read then it will be performed .If source is a File object the read method of File class would be called. If the source does not have read method then it is checked wheather it have to_s method. If it has then to_s is called on the source to convert it to string and send it as parameter to read method. Hence type of source doesn't matter unless it have to_s or read method. Thus implementing duck typing style where objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type. 


Type checking can be done in ruby using a case statement or we can also check type of object using class method.
eg)
def half param
case param
when String
return param[0...param.length/2]
when Fixnum
return param/2
else
 raise TypeError, "Wrong argument type"
end
end
puts half(10)      # returns 5
puts half("abcd")  # returns ab
puts half(1.2)     # throws exception

In above example the type of the argument provided to the half method is checked by using case statement , if it is of type string then the same string truncated to the half of its length is returned. If the argument supplied is of type Fixnum the its divided by 2 and returned. If it is of any other type it raises exception.










