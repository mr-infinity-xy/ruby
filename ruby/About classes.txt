Data can be stored for entire class instead of instance of a class. Class variable have single copy for each class while instance variable have one copy for each object.
Class variable can be created using @@ symbol.
eg)
class Polygon
  @@var = 1
  def self.var
    @@var
  end
  def set_class_var_val val
  	@@var=val
  end
  def get_class_var_val
  	puts @@var
  end
end
p1=Polygon.new
p2=Polygon.new
puts "value of var for p1 "
p1.get_class_var_val 
puts "value of var for p2 "
p2.get_class_var_val 

p1.set_class_var_val 4

puts "value of var for p1 "
p1.get_class_var_val 
puts "value of var for p2 "
p2.get_class_var_val 

o/p
value of var for p1
1
value of var for p2
1
value of var for p1
4
value of var for p2
4

Values for @@var is same for all the object as it is a class variable.
If variable was a instance variable then the o/p would be
value of var for p1
1
value of var for p2
1
value of var for p1
4
value of var for p2
1


Method overloading can be achieved by declaring two methods with the same name and different signatures. These different signatures can be either
a)Arguments with different data types eg: method(int a, int b) vs method(String a, String b)
b)Variable number of arguments, eg: method(a) vs method(a, b)

We cannot achieve method overloading using the first way because there is no data type declaration in ruby(dynamic typed language). So the only way to define the above method is def(a,b)
With the second option it look like we can achieve method overloading, but we can't. Let say I have two methods with different number of arguments,
def method(a); end;
def method(a, b = true); end; # second argument has a default value
method(10)
# Now the method call can match the first one as well as the second one, 

Ruby class can have only one method with a given name (if you define a method with the same name twice, the latter method definition prevails as seen in example



Class Variables
Class variables are easy. It can be created using @@ to denote the variable as class level and add a getter method like so:
class Polygon
  @@sides = 10
  def self.sides
    @@sides
  end
end

puts Polygon.sides # => 10
The issue with class variables is inheritance. Let’s say I want to subclass Polygon with Triangle like so:

class Triangle < Polygon
  @@sides = 3
end

puts Triangle.sides # => 3
puts Polygon.sides # => 3
Wha? But Polygon’s sides was set to 10? When you set a class variable, you set it for the superclass and all of the subclasses.

Class Level Instance Variables
Ok, so what is a Rubyist to do? Let’s think for a second. What is a class? It’s an object. What can objects have? Objects can have class and instance variables. This means that a class can have instance variables. Let’s reopen our Polygon class and add an instance variable:

class Polygon
  @sides = 10
end
Now, you can use some reflection to check out Polygon’s class and instance variables:

puts Polygon.class_variables # => @@sides
puts Polygon.instance_variables # => @sides
Interesting. So let’s try this inheritance thing again, starting from scratch and this time we’ll use class level instance variables.

class Polygon
  attr_accessor :sides
  @sides = 10
end

puts Polygon.sides # => NoMethodError: undefined method ‘sides’ for Polygon:Class
So why the error? We created the instance method getter and setter using attr_accessor and set the sides instance variable to 10. This is where it is tricky. The attr_accessor created the getter and setter methods for an instance of Polygon, not for the Polygon class itself. Try this:

puts Polygon.new.sides # => nil
We get nil, not method undefined. Now it makes sense, eh? We created methods for the instance method sides. So how do you create a class level instance method?

class Polygon
  class << self; attr_accessor :sides end
  @sides = 8
end

puts Polygon.sides # => 8
This adds the side attribute accessor methods to the class level rather than the instance level. What we are left with is a class level instance variable. So now let’s try inheritance:

class Triangle < Polygon
  @sides = 3
end

puts Triangle.sides # => 3
puts Polygon.sides # => 8
Botta bing. Now each class can have it’s own number of sides. Now the issue is how to set a default value. One would assume that the following would produce 8, which is the default for Polygon…

class Octogon < Polygon; end
puts Octogon.sides # => nil