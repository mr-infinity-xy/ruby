http://blog.khd.me/ruby/delegation-in-ruby/


Enumerable method

a)all? [{ |obj| block } ] 
Passes each element of the collection to the given block. The method returns true if the block never returns false or nil. If the block is not given, Ruby adds an implicit block of { |obj| obj } which will cause all? to return true when none of the collection members are false or nil.
eg)
[2, 3, 4].all? { |val| val > 1 } # true
[2, 3, 4].all? { |val| val > 3 } #false
          
b)any? [{ |obj| block }] 
Passes each element of the collection to the given block. The method returns true if the block ever returns a value other than false or nil. If the block is not given, Ruby adds an implicit block of { |obj| obj } that will cause any? to return true if at least one of the collection members is not false or nil.
eg)
[2, 3, 4].any? { |val| val > 2 } # true
[2, 3, 4].any? { |val| val < 1 } #false

c)collect { |obj| block } 
Returns a new array with the results of running block once for every element in enum.
eg)
(1..4).map { |i| i }      # [1, 2, 3, 4]

d)collect_concat { |obj| block }
Returns a new array with the concatenated results of running block once for every element in enum.
eg)
[1, 2, 3, 4].flat_map { |v| [v, v*2] } # [1, 2, 2, 4, 3, 6, 4, 8]

e)count, count(item), count { |obj| block } 
Returns the number of items in enum through enumeration. If an argument is given, the number of items in enum that are equal to item are counted. If a block is given, it counts the number of elements yielding a true value.
eg)
ary = [1, 2, 2, 4, 5]
ary.count               # 5
ary.count(2)            # 2
ary.count{ |x| x > 2 }  # 2

f)select {|item| block }
Select basically iterates through all the elements in your array and performs your logic on each one. If the logic returns TRUE, then it adds the item to a new array which it returns when the iteration is complete.
 eg)
a = [1,2,3,4]
a.select {|n| n > 2}
This will return the last two elements in the array i.e 3 and 4. Because 3 and 4 are both greater than 2, which was the logic we placed in the block. I

g)reject {|item| block } 
reject will perform the opposite operation of select. Logic which returns FALSE adds the item to the array that is returned. 
eg)
a = [1,2,3,4]
a.reject {|n| n > 2}  # returns [1,2]


h)inject {|accumulator,item| block } 
When we think of accumulating, concatenating, or totaling values in an array, then we use inject. The main difference between select and inject is that inject gives you another variable for use in the block. This variable, referred to as the accumulator, is used to store the running total or concatenation of each iteration. 
eg)
a = [1,2,3,4]
a.inject {|acc,n| acc + n} # returns 10

i)detect(ifnone = nil) { |obj| block } 
Passes each entry in array to block. Returns the first for which block is not false. If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise.
eg)
a = [1,2,3,4]
a.detect {|n| n == 3} # returns 3

j)drop(n)
Drops first n elements from enum, and returns rest elements in an array.
eg)
a = [1, 2, 3, 4, 5, 0]
a.drop(3)      # returns [4, 5, 0]



class Family
  attr_accessor :father, :surname, :mother, :child

  include Enumerable
  def each
    yield "#{@father} #{@surname}"
    yield "#{@mother} #{@father} #{surname}"
    yield "#{@child} #{@father} #{surname}"
  end
end
f = Family.new
f.father = 'father_name'
f.surname= 'surname'
f.mother = 'mother_name'
f.child = 'child_name'

puts f.map{|f| "Family member: #{f}" }
p f.detect{ |f| f== "father_name surname" }
p f.select{ |f| f[0]=="f" || f[0]=="m" }
p f.sort{|x,y| y<=>x}



Enumerable
In previous chapters you’ve performed the process of iteration, like so:
[1,2,3,4,5].each { |number| puts number }
In this case, you create a temporary array containing the numbers one through five and
use the each iterator to pass each value into the code block, assigning each value to number that
you then print to the screen with puts.
The each iterator gives you a lot of power, as it allows you to go through all the elements of
an array or a hash and use the data you retrieve to work out, for example, the mean of an array
of numbers, or the length of the longest string in an array, like so:
my_array = %w{this is a test of the longest word check}
longest_word = ''
my_array.each do |word|
longest_word = word if longest_word.length < word.length
end
puts longest_word
longest
Download at Boykma.Com
144 Chapter 6 ■ ﻿ CLASSES, OBJECTS, AND MODULES
In this case, you loop through my_array, and if the currently stored longest word is shorter
than the length of word, you assign it to longest_word. When the loop finishes, the longest word
is in longest_word.
The same code could be tweaked to find the largest (or smallest) number in a set of
numbers:
my_array = %w{10 56 92 3 49 588 18}
highest_number = 0
my_array.each do |number|
number = number.to_i
highest_number = number if number > highest_number
end
puts highest_number
588
However, the Array class (for one) has pre-included the methods provided by the
Enumerable
module, a module that supplies about 20 useful counting- and iteration-related
methods, including collect, detect, find, find_all, include?, max, min, select, sort, and to_a.
All of these use Array’s each method to do their jobs, and if your class can implement an each
method, you can include Enumerable, and get all those methods for free in your own class!
nNote The main methods provided by Enumerable are referenced in Appendix B.
First, some examples of the methods provided by Enumerable:
[1,2,3,4].collect { |i| i.to_s + "x" }
=> ["1x", "2x", "3x", "4x"]
[1,2,3,4].detect { |i| i.between?(2,3) }
=> 2
[1,2,3,4].select { |i| i.between?(2,3) }
=> [2,3]
[4,1,3,2].sort
Download at Boykma.Com
Chapter 6 ■﻿ CLASSES, OBJECTS, AND MODULES 145
=> [1,2,3,4]
[1,2,3,4].max
=> 4
[1,2,3,4].min
=> 1
You can make your own class, implement an each method, and get these methods for “free:”
class AllVowels
@@vowels = %w{a e i o u}
def each
@@vowels.each { |v| yield v }
end
end
This is a class that, in reality, doesn’t need to provide multiple objects, as it only provides
an enumeration of vowels. However, to keep the demonstration simple, it is ideal. Here’s how
it works:
x = AllVowels.new
x.each { |v| puts v }
a
e
i
o
u
Your AllVowels class contains a class array containing the vowels, and the instance-level
each method iterates through the class array @@vowels and yields to the code block supplied to
each, passing in each vowel, using yield v. Let’s get Enumerable involved:
class AllVowels
include Enumerable
@@vowels = %w{a e i o u}
def each
@@vowels.each { |v| yield v }
end
end
Download at Boykma.Com
146 Chapter 6 ■ ﻿ CLASSES, OBJECTS, AND MODULES
nNote yield and its relationship to code blocks was covered near the end of Chapter 3; refer to that if you
need a refresher.
Now let’s try to use those methods provided by Enumerable again. First let’s get an
AllVowels
object:
x = AllVowels.new
Now you can call the methods upon x:
x.collect { |i| i + "x" }
=> ["ax", "ex", "ix", "ox", "ux"]
x.detect { |i| i > "j" }
=> "o"
x.select { |i| i > "j" }
=> ["o", "u"]
x.sort
=> ["a", "e", "i", "o", "u"]
x.max
=> "u"
x.min
=> "a"
Download at Boykma.Com
