Enumerable
In previous chapters you’ve performed the process of iteration, like so:
[1,2,3,4,5].each { |number| puts number }
In this case, you create a temporary array containing the numbers one through five and
use the each iterator to pass each value into the code block, assigning each value to number that
you then print to the screen with puts.
The each iterator gives you a lot of power, as it allows you to go through all the elements of
an array or a hash and use the data you retrieve to work out, for example, the mean of an array
of numbers, or the length of the longest string in an array, like so:
my_array = %w{this is a test of the longest word check}
longest_word = ''
my_array.each do |word|
longest_word = word if longest_word.length < word.length
end
puts longest_word
longest
Download at Boykma.Com
144 Chapter 6 ■ ﻿ CLASSES, OBJECTS, AND MODULES
In this case, you loop through my_array, and if the currently stored longest word is shorter
than the length of word, you assign it to longest_word. When the loop finishes, the longest word
is in longest_word.
The same code could be tweaked to find the largest (or smallest) number in a set of
numbers:
my_array = %w{10 56 92 3 49 588 18}
highest_number = 0
my_array.each do |number|
number = number.to_i
highest_number = number if number > highest_number
end
puts highest_number
588
However, the Array class (for one) has pre-included the methods provided by the
Enumerable
module, a module that supplies about 20 useful counting- and iteration-related
methods, including collect, detect, find, find_all, include?, max, min, select, sort, and to_a.
All of these use Array’s each method to do their jobs, and if your class can implement an each
method, you can include Enumerable, and get all those methods for free in your own class!
nNote The main methods provided by Enumerable are referenced in Appendix B.
First, some examples of the methods provided by Enumerable:
[1,2,3,4].collect { |i| i.to_s + "x" }
=> ["1x", "2x", "3x", "4x"]
[1,2,3,4].detect { |i| i.between?(2,3) }
=> 2
[1,2,3,4].select { |i| i.between?(2,3) }
=> [2,3]
[4,1,3,2].sort
Download at Boykma.Com
Chapter 6 ■﻿ CLASSES, OBJECTS, AND MODULES 145
=> [1,2,3,4]
[1,2,3,4].max
=> 4
[1,2,3,4].min
=> 1
You can make your own class, implement an each method, and get these methods for “free:”
class AllVowels
@@vowels = %w{a e i o u}
def each
@@vowels.each { |v| yield v }
end
end
This is a class that, in reality, doesn’t need to provide multiple objects, as it only provides
an enumeration of vowels. However, to keep the demonstration simple, it is ideal. Here’s how
it works:
x = AllVowels.new
x.each { |v| puts v }
a
e
i
o
u
Your AllVowels class contains a class array containing the vowels, and the instance-level
each method iterates through the class array @@vowels and yields to the code block supplied to
each, passing in each vowel, using yield v. Let’s get Enumerable involved:
class AllVowels
include Enumerable
@@vowels = %w{a e i o u}
def each
@@vowels.each { |v| yield v }
end
end
Download at Boykma.Com
146 Chapter 6 ■ ﻿ CLASSES, OBJECTS, AND MODULES
nNote yield and its relationship to code blocks was covered near the end of Chapter 3; refer to that if you
need a refresher.
Now let’s try to use those methods provided by Enumerable again. First let’s get an
AllVowels
object:
x = AllVowels.new
Now you can call the methods upon x:
x.collect { |i| i + "x" }
=> ["ax", "ex", "ix", "ox", "ux"]
x.detect { |i| i > "j" }
=> "o"
x.select { |i| i > "j" }
=> ["o", "u"]
x.sort
=> ["a", "e", "i", "o", "u"]
x.max
=> "u"
x.min
=> "a"
Download at Boykma.Com
