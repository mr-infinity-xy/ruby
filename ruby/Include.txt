Extend
  Adds the specified module's methods and constants to the target's metaclass i.e. the singleton class
e.g
If we call Klass.extend(Mod), now Klass has Mod's methods as a class methods
if you call obj.extend(Mod), now obj has Mod's methods as instance methods, but no other instance of of obj.class has those methods.
extend is a public method
include - By default, it mixes in the specified module's methods as instance methods in the target module/class. 
e.g.
if you call class Klass; include Mod; end; now all instances of Klass have access to Mod's methods as instance methods
include is a private method, because it's intended to be called from within the container class.

Example of extend
module A
def method
 puts "Method called"
end
end
class ExtendModule
extend A            # all method of module A acts as a class method of class ExtendModule
end
ExtendModule.method  # prints Method called

Example of include
module A
def method
 puts "Method called"
end
end
class ExtendModule
include A            # all method of module A acts as a instance method of class ExtendModule
end
ExtendModule.new.method  # prints Method called





Include
When you Include a module into our class as shown below, it took the code defined within the module and inserted it within the class, where you ‘include’ it. It allows the ‘mixin’ behavior. Its used to avoid duplication, for instance, if there were multiple classes that would need the same code within the module.
The following assumes that the module Log and class TestClass are defined in the same .rb file. If they were in separate files then ‘load’ or ‘require’ must be used to let the class know about the module we have defined.
eg)
module Info 
  def class_name obj
     obj.class
  end
end
class Test 
  include Info
end
puts Test.new("a")

o/p
String

Load
The load method is almost like the require method except it doesn’t keep track of whether or not that library has been loaded. So it’s possible to load a library multiple times and also when using the load method we must specify the “.rb” extension of the library file name.
Most of the time we will want to use require instead of load but load is there if we want a library to be loaded each time load is called. For example if your module changes its state frequently, we may want to use load to pick up those changes within classes loaded from.
eg)
load 'test_library.rb'  # contains info module
class TestClass 
  include Info 
end

Require
The require method allows we to load a library and prevents it from being loaded more than once. The require method will return false if we try to load the same library after the first time. The require method only needs to be used if library we are loading is defined in a separate file, which is usually the case. So it keeps track of whether that library was already loaded or not. We also don’t need to specify the “.rb” extension of the library file name.
eg)
require 'test_library'

Extend
When using the extend method instead of include, we are adding the module’s methods as class methods instead of as instance methods.
eg)
module Info 
  def class_name obj
     obj.class
  end
end
class Test
  extend Info 
end
puts TestClass.class_name

o/p
String
When using extend instead of include within the class, if we try to instantiate Test class and call method class_name on it, as we did in the include example above, we will get a NoMethodError. 