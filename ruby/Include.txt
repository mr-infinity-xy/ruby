Include
When you Include a module into our class as shown below, it took the code defined within the module and inserted it within the class, where you ‘include’ it. It allows the ‘mixin’ behavior. Its used to avoid duplication, for instance, if there were multiple classes that would need the same code within the module.
The following assumes that the module Log and class TestClass are defined in the same .rb file. If they were in separate files then ‘load’ or ‘require’ must be used to let the class know about the module we have defined.
eg)
module Info 
  def class_name obj
     obj.class
  end
end
class Test 
  include Info
end
puts Test.new("a")

o/p
String

Load
The load method is almost like the require method except it doesn’t keep track of whether or not that library has been loaded. So it’s possible to load a library multiple times and also when using the load method we must specify the “.rb” extension of the library file name.
Most of the time we will want to use require instead of load but load is there if we want a library to be loaded each time load is called. For example if your module changes its state frequently, we may want to use load to pick up those changes within classes loaded from.
eg)
load 'test_library.rb'  # contains info module
class TestClass 
  include Info 
end

Require
The require method allows we to load a library and prevents it from being loaded more than once. The require method will return false if we try to load the same library after the first time. The require method only needs to be used if library we are loading is defined in a separate file, which is usually the case. So it keeps track of whether that library was already loaded or not. We also don’t need to specify the “.rb” extension of the library file name.
eg)
require 'test_library'

Extend
When using the extend method instead of include, we are adding the module’s methods as class methods instead of as instance methods.
eg)
module Info 
  def class_name obj
     obj.class
  end
end
class Test
  extend Info 
end
puts TestClass.class_name

o/p
String

When using extend instead of include within the class, if we try to instantiate Test class and call method class_name on it, as we did in the include example above, we will get a NoMethodError. 